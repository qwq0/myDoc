2023/07/27

突然想到的一种字符串cmp方案 复杂度O(log(n))

传统的字符串cmp一般会逐个比较字符

如果字符串起始位置大量重复 就会最坏O(n)复杂度

现在我们考虑一种很新的cmp方式

对于长度为n的字符串 预处理时间代价O(n) 预处理空间代价O(n)

得到一个哈希数组 数组的每一个元素标识这个字符串的s[0, i]字串的哈希

需要使用每个哈希方法是可以通过前面的已经处理过的哈希并以O(1)获得当前值的方案

之后 在比较两个字符串的时候

首先对比两个字符串的哈希数组 从最末尾开始对比 二分查找得到最前面的哈希值不同的位置

然后对比这个地方的字符就能比较出两个字符串的字典序了

因为前面的二分查找复杂度是logn 所以这就是比较的复杂度

---

另外 由于防止哈希碰撞 所以哈希数组的空间复杂度常数较大

可以想到一种以时间常数换取空间常数的方法

也就是对每k个字符只用一个哈希数组中的值对应

也就是哈希数组中下标为i的元素对应的是字符串s[0, (i + 1) * k - 1]的哈希值

这样空间复杂度常数降低到1/k

但最后的比较从单个字符变成了最多k个字符 也就是s[i * k, (i + 1) * k - 1]的比较

时间常数加上了k

---

另外 对于比较短的字符串比较或在前面几乎不会完全相同的字符串的比较

比如完全随机生成的字符串 或者较短的字符串

使用这个cmp方案其实得不偿失 因为会有额外的空间浪费但不会节约多少时间

在 较长的 可能前面有字符大量相同的 字符串间的字典序比较时 可以考虑这种方案显著降低最坏时间复杂度